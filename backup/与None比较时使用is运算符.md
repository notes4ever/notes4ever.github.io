== 的行为可被魔法方法改变，那我们如何严格检查某个对象是否为 None 呢？答案是使用 is 运算符。

虽然二者看上去差不多，但有着本质上的区别：

- == 对比两个对象的值是否相等，行为可被 __eq__ 方法重载；
- is 判断两个对象是否是内存里的同一个东西，无法被重载。

换句话说，当你在执行 x is y 时，其实就是在判断 id(x) 和 id(y) 的结果是否相等，二者是否是同一个对象。

除了 **None、True 和 False** 这三个内置对象以外，其他类型的对象在 Python 中并不是严格以**单例模式**存在的。换句话说，即便值一致，它们在内存中仍然是完全不同的两个对象。

因此，**仅当你需要判断某个对象是否是 None、True、False 时，使用 is，其他情况下，请使用 ==**。

Python中令人迷惑的**整型驻留**技术：
```
>>> x = 6300
>>> y = 6300
>>> x is y
False

# 它们在内存中是不同的两个对象
>>> id(x), id(y)
(4412016144, 4412015856)
```

假如我们稍微调整一下上面的代码，把数字从 6300 改成 100，会获得完全相反的执行结果：
```
>>> x = 100
>>> y = 100
>>> x is y
True

# 二者 id 相等，在内存中是同一个对象
>>> id(x), id(y)
(4302453136, 4302453136)
```

为什么会这样？这是因为 Python 语言使用了一种名为“整型驻留”（integer interning）的底层优化技术。

对于从 -5 到 256 的这些常用小整数，Python 会将它们缓存在内存里的一个数组中。当你的程序需要用到这些数字时，Python 不会创建任何新的整型对象，而是会返回缓存中的对象。这样能为程序节约可观的内存。

除了整型以外，Python 对字符串也有类似的“驻留”操作。如果你对这方面感兴趣，可自行搜索“Python integer/string interning”关键字了解更多内容。